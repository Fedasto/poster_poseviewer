<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>QR Pose Viewer with Recording</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: sans-serif; background: #111; color: #fff; text-align: center; margin:0; padding:20px; }
  video, canvas { width: 90vw; max-width: 600px; border-radius:8px; background:#000; }
  #info { margin-top: 12px; white-space: pre; font-size: 14px; }
  #startBtn, #startRecBtn, #stopRecBtn { margin: 12px; padding: 10px 16px; font-size:16px; border-radius:8px; }

  #instructions {
    background:#222; padding:15px; border-radius:10px; margin-bottom:15px;
    text-align:left; max-width:600px; margin-left:auto; margin-right:auto;
    font-size:14px; line-height:1.4;
  }

  #plotCanvas { margin-top:12px; background:#222; border-radius:8px; }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>QR Pose Viewer with Recording</h2>

<div id="instructions">
<b>Instructions:</b><br>
1. Press <b>Start Camera</b>.<br>
2. Point your device at a 10 cm QR code.<br>
3. Press <b>Start Recording</b> to collect pose samples.<br>
4. Press <b>Stop Recording</b> to downsample & plot (~10 frames).<br>
5. rvec is shown in <b>degrees</b>, tvec in <b>centimeters</b>.
</div>

<button id="startBtn">Start Camera</button><br>
<button id="startRecBtn">Start Recording</button>
<button id="stopRecBtn">Stop Recording</button>
<br>

<video id="video" playsinline autoplay muted></video>
<canvas id="canvas"></canvas>
<div id="info">Initializing...</div>
<canvas id="plotCanvas" style="width:90vw; max-width:600px; height:300px;"></canvas>

<script>
let video = document.getElementById('video');
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let info = document.getElementById('info');

let initialized = false;
let cameraMatrix, distCoeffs;
let qrDetector;

// Recording
let rvecHistory = [];
let tvecHistory = [];
let recording = false;

const qrSize = 0.10; // 10 cm QR code

function downsample(arr, targetCount=10) {
    if (arr.length <= targetCount) return arr;
    let step = arr.length / targetCount;
    let out = [];
    for (let i = 0; i < targetCount; i++) {
        out.push(arr[Math.floor(i * step)]);
    }
    return out;
}

async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } },
      audio: false
    });
    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.onloadedmetadata = () => video.play().then(()=>resolve()).catch(reject);
      setTimeout(() => {
        if (video.videoWidth > 0) resolve();
        else reject(new Error("Timed out waiting for video metadata"));
      }, 3000);
    });
  } catch (err) {
    throw err;
  }
}

function onOpenCVReady() {
    cv['onRuntimeInitialized'] = async () => {
        await startApplication();
    };
}

async function startApplication() {
    info.textContent = "Loading camera...";
    try {
        await initCamera();
        qrDetector = new cv.QRCodeDetector();

        let w = video.videoWidth  || 1080;
        let h = video.videoHeight || 1920;

        const HFOV = 85 * Math.PI / 180;
        const fx = (w / 2) / Math.tan(HFOV / 2);
        const VFOV = 2 * Math.atan((h / w) * Math.tan(HFOV / 2));
        const fy = (h / 2) / Math.tan(VFOV / 2);
        const cx = w / 2, cy = h / 2;

        cameraMatrix = cv.matFromArray(3, 3, cv.CV_64F, [
            fx, 0,  cx,
            0,  fy, cy,
            0,  0,   1
        ]);

        distCoeffs = cv.Mat.zeros(5, 1, cv.CV_64F);

        initialized = true;
        info.textContent = "Point your camera at a QR code.";
        tick();
    } catch (error) {
        info.textContent = "Camera error: " + error;
    }
}

document.getElementById('startRecBtn').addEventListener('click', () => {
    rvecHistory = [];
    tvecHistory = [];
    recording = true;
    info.textContent = "Recording poses...";
});

document.getElementById('stopRecBtn').addEventListener('click', () => {
    recording = false;
    info.textContent = "Recording stopped. Plotting...";
    plotPoses();
});

function tick() {
    if (!initialized || !cv) {
        requestAnimationFrame(tick);
        return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    let points = new cv.Mat();
    let straight_qrcode = new cv.Mat();

    if (qrDetector.detect(gray, points)) {
        qrDetector.decode(gray, points, straight_qrcode);

        // Object points
        let objPoints = cv.matFromArray(4,1,cv.CV_32FC3, [
            0,0,0,
            qrSize,0,0,
            qrSize,qrSize,0,
            0,qrSize,0
        ]);
        let imagePoints = cv.matFromArray(4,1,cv.CV_32FC2, points.data32F);

        let rvec = new cv.Mat();
        let tvec = new cv.Mat();
        let ok = cv.solvePnP(objPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec);

        if (ok) {
            // Convert
            let r = Array.from(rvec.data64F).map(v => v * 180 / Math.PI);
            let t = Array.from(tvec.data64F).map(v => v * 100);

            info.textContent =
                `rvec (deg): [${r.map(v=>v.toFixed(2)).join(", ")}]\n` +
                `tvec (cm):  [${t.map(v=>v.toFixed(2)).join(", ")}]`;

            if (recording) {
                rvecHistory.push(r);
                tvecHistory.push(t);
            }
        }

        objPoints.delete(); imagePoints.delete(); rvec.delete(); tvec.delete();
    } else {
        info.textContent = "No QR code detected";
    }

    cv.imshow(canvas, src);
    src.delete(); gray.delete(); points.delete(); straight_qrcode.delete();

    requestAnimationFrame(tick);
}

function plotPoses() {
    // Downsample to ~10 frames
    let r10 = downsample(rvecHistory, 10);
    let t10 = downsample(tvecHistory, 10);

    let labels = r10.map((_,i)=>i);

    new Chart(document.getElementById('plotCanvas'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label:"rvec X (deg)", data:r10.map(v=>v[0]), borderColor:"red" },
                { label:"rvec Y (deg)", data:r10.map(v=>v[1]), borderColor:"green" },
                { label:"rvec Z (deg)", data:r10.map(v=>v[2]), borderColor:"blue" },
                { label:"tvec X (cm)",  data:t10.map(v=>v[0]), borderColor:"orange" },
                { label:"tvec Y (cm)",  data:t10.map(v=>v[1]), borderColor:"purple" },
                { label:"tvec Z (cm)",  data:t10.map(v=>v[2]), borderColor:"cyan" }
            ]
        },
        options:{
            responsive:true,
            animation:false,
            plugins:{ legend:{ position:'top' } }
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    info.textContent = "Loading OpenCV...";
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('startBtn').style.display = 'none';
        if (typeof cv !== 'undefined' && cv && cv['onRuntimeInitialized']) {
            // runtime will start automatically
        } else {
            onOpenCVReady();
        }
    });
});
</script>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCVReady()"></script>

</body>
</html>
