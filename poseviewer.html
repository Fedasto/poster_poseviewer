<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>QR Pose Viewer with Recording</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body { font-family: sans-serif; background: #111; color: #fff; text-align: center; margin:0; padding:20px; }
  video, canvas { width: 90vw; max-width: 600px; border-radius:8px; background:#000; }
  #info { margin-top: 12px; white-space: pre; font-size: 14px; }
  #startBtn, #startRecBtn, #stopRecBtn { margin: 12px; padding: 10px 16px; font-size:16px; border-radius:8px; }
  #plotCanvas { margin-top:12px; background:#222; border-radius:8px; }
</style>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>QR Pose Viewer with Recording</h2>

<button id="startBtn">Start Camera</button><br>
<button id="startRecBtn">Start Recording</button>
<button id="stopRecBtn">Stop Recording</button>
<br>

<video id="video" playsinline autoplay muted></video>
<canvas id="canvas"></canvas>
<div id="info">Initializing...</div>
<canvas id="plotCanvas" style="width:90vw; max-width:600px; height:300px;"></canvas>

<script>
let video = document.getElementById('video');
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let info = document.getElementById('info');

let initialized = false;
let cameraMatrix, distCoeffs;
let qrDetector;

const qrSize = 0.10; // 10 cm QR code

// Recording arrays
let rvecHistory = [];
let tvecHistory = [];
let recording = false;

async function initCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: "environment" } },
      audio: false
    });
    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.onloadedmetadata = () => video.play().then(()=>resolve()).catch(reject);
      setTimeout(() => {
        if (video.videoWidth > 0) resolve();
        else reject(new Error("Timed out waiting for video metadata"));
      }, 3000);
    });
  } catch (err) {
    throw err;
  }
}

function onOpenCVReady() {
    console.log("OpenCV.js loaded");
    cv['onRuntimeInitialized'] = async () => {
        console.log("OpenCV runtime initialized");
        await startApplication();
    };
}

async function startApplication() {
    info.textContent = "Loading camera...";
    try {
        await initCamera();
        qrDetector = new cv.QRCodeDetector();

        let w = video.videoWidth  || 1080;
        let h = video.videoHeight || 1920;

        // --- Samsung S23+ main camera HFOV = 85° ---
        const HFOV_DEG = 85.0;
        const HFOV = HFOV_DEG * Math.PI / 180;

        // Focal lengths in pixels (derived from FOV)
        const fx = (w / 2) / Math.tan(HFOV / 2);
        const VFOV = 2 * Math.atan((h / w) * Math.tan(HFOV / 2));
        const fy = (h / 2) / Math.tan(VFOV / 2);

        // Principal point (center)
        const cx = w / 2;
        const cy = h / 2;

        cameraMatrix = cv.matFromArray(3, 3, cv.CV_64F, [
            fx, 0,  cx,
            0,  fy, cy,
            0,  0,   1
        ]);

        // Distortion coefficients — zero is safest
        distCoeffs = cv.Mat.zeros(5, 1, cv.CV_64F);

        initialized = true;
        info.textContent = "Point your camera at a QR code.";
        tick();

    } catch (error) {
        console.error(error);
        info.textContent = "Camera error: " +
            (error && error.message ? error.message : error);
    }
}


// Start / stop recording buttons
document.getElementById('startRecBtn').addEventListener('click', () => {
    rvecHistory = [];
    tvecHistory = [];
    recording = true;
    info.textContent = "Recording poses...";
});

document.getElementById('stopRecBtn').addEventListener('click', () => {
    recording = false;
    info.textContent = "Recording stopped. Plotting...";
    plotPoses();
});

// Tick function
function tick() {
    if (!initialized || !cv) {
        requestAnimationFrame(tick);
        return;
    }

    canvas.width = video.videoWidth || canvas.width;
    canvas.height = video.videoHeight || canvas.height;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    let points = new cv.Mat();
    let straight_qrcode = new cv.Mat();

    if (qrDetector.detect(gray, points)) {
        qrDetector.decode(gray, points, straight_qrcode);

        // Draw QR boundary
        for (let i = 0; i < 4; i++) {
            let pt1 = new cv.Point(points.data32F[i*2], points.data32F[i*2+1]);
            let pt2 = new cv.Point(points.data32F[((i+1)%4)*2], points.data32F[((i+1)%4)*2+1]);
            cv.line(src, pt1, pt2, [0,255,0,255], 2);
        }

        // Solve PnP
        let objPoints = cv.matFromArray(4,1,cv.CV_32FC3, [
            0,0,0,
            qrSize,0,0,
            qrSize,qrSize,0,
            0,qrSize,0
        ]);
        let imagePoints = cv.matFromArray(4,1,cv.CV_32FC2, points.data32F);

        let rvec = new cv.Mat();
        let tvec = new cv.Mat();
        let success = cv.solvePnP(objPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, false, cv.SOLVEPNP_ITERATIVE);

        if (success) {
            info.textContent = `rvec: [${Array.from(rvec.data64F).map(x=>x.toFixed(3)).join(", ")}]\n` +
                               `tvec: [${Array.from(tvec.data64F).map(x=>x.toFixed(3)).join(", ")}]`;

            if (recording) {
                rvecHistory.push(Array.from(rvec.data64F));
                tvecHistory.push(Array.from(tvec.data64F));
            }
        }

        // Draw axes
        let axisLength = 0.05;
        let axis = cv.matFromArray(3,3,cv.CV_32FC3, [
            axisLength,0,0,
            0,axisLength,0,
            0,0,axisLength
        ]);
        let imgpts = new cv.Mat();
        cv.projectPoints(axis, rvec, tvec, cameraMatrix, distCoeffs, imgpts);
        let corner = new cv.Point(points.data32F[0], points.data32F[1]);
        cv.line(src, corner, new cv.Point(imgpts.data32F[0], imgpts.data32F[1]), [0,0,255,255], 3);
        cv.line(src, corner, new cv.Point(imgpts.data32F[3], imgpts.data32F[4]), [0,255,0,255], 3);
        cv.line(src, corner, new cv.Point(imgpts.data32F[6], imgpts.data32F[7]), [255,0,0,255], 3);

        objPoints.delete(); imagePoints.delete(); rvec.delete(); tvec.delete(); axis.delete(); imgpts.delete();
    } else {
        info.textContent = "No QR code detected";
    }

    cv.imshow(canvas, src);
    src.delete(); gray.delete(); points.delete(); straight_qrcode.delete();

    requestAnimationFrame(tick);
}

// Plot poses with Chart.js
function plotPoses() {
    const labels = rvecHistory.map((_, i) => i);

    const data = {
        labels: labels,
        datasets: [
            { label: 'rvec X', data: rvecHistory.map(v=>v[0]), borderColor: 'red', fill:false },
            { label: 'rvec Y', data: rvecHistory.map(v=>v[1]), borderColor: 'green', fill:false },
            { label: 'rvec Z', data: rvecHistory.map(v=>v[2]), borderColor: 'blue', fill:false },
            { label: 'tvec X', data: tvecHistory.map(v=>v[0]), borderColor: 'orange', fill:false },
            { label: 'tvec Y', data: tvecHistory.map(v=>v[1]), borderColor: 'purple', fill:false },
            { label: 'tvec Z', data: tvecHistory.map(v=>v[2]), borderColor: 'cyan', fill:false },
        ]
    };

    new Chart(document.getElementById('plotCanvas'), {
        type: 'line',
        data: data,
        options: { responsive:true, plugins:{ legend:{ position:'top' } } }
    });
}

document.addEventListener('DOMContentLoaded', function() {
    info.textContent = "Loading OpenCV...";
    document.getElementById('startBtn').addEventListener('click', async () => {
        document.getElementById('startBtn').style.display = 'none';
        if (typeof cv !== 'undefined' && cv && cv['onRuntimeInitialized']) {
            // runtime will call startApplication
        } else {
            onOpenCVReady();
        }
    });
});

// Load OpenCV.js
</script>
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCVReady()"></script>

</body>
</html>
